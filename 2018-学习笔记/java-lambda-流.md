##### java集合学习手迹###### 集合类基础通识泛型只在编译期有效:List<? extends Number> numberList = integerList;才正确泛型方法   <S>void printClass (Class<S> clazz) {    }   ， 作用避免写重复的方法List&& Guava中的Lists:arraylist可以更好的利用cpu的cache，按索引取值，删添中间元素需要移动后面的元素，linkedlist取值需遍历Map:HashMap的哈希冲突怎么处理？LinkedHashMap：保存插入顺序TreeMap： key有序，可使用自定义的ComparatorEnumMap :  Guava中的Maps和SetsSet:  Collections.newSetFromMap ,  常用操作add,contains以上所提均为线程不安全###### 集合类的线程安全(不推荐Vector,Table,Stack)List  -   CopyOnWriteArrayList: 写少读多Map -  ConcurrentMap接口与ConcurrentHashMap:无序Set  -   CopyOnWriteArraySet###### 不可变的集合类（使用Guava的）List<Integer>  data = new ArrayList<>();List<Integer>  immutableData =  ImmutableList.copyOf(data);###### Queue , Deque, Tablequeue常用于生产者、消费者模式中BlockingQueue : 实现为线程安全的，分为ArrayBlockingQueue和LinkedBlockingQueueDeque: 栈BlockingDeque : 实现为线程安全， 具体为LinkedBlockingDeque,  但ArrayDeque为非线程安全###### 在java包中新增的函数式接口  --  函数式编程@FunctionalInterface指一个接口只有一个非default,非static的接口如Function接口，Predicate接口Cunsumer接口、Supplier接口以及如何扩展？考虑如下几个因素：参数个数、泛型关系限制、基本类型、返回值类型。。。。。如BiFunction接口、BiConsumer接口泛型关系限制，如这个接口：@FunctionalInterfacepublic interface UnaryOperator<T> extends Function<T,T>{​     static <T> UnaryOperator<T> identity() { return t -> t ; }}参数基本类型, 如：@FunctionalInterfacepublic interface IntFunction<R>{​    R  apply (int value);}@FunctionalInterfacepublic interface BooleanSupplier{  boolean getAsBoolean();  }还有各种组合如：@FunctionalInterfacepublic interface DoubleToLongFunction{ long applyAsLong ( double value ) ;  }###### lambda表达式- 以->为界 ， 左边是参数，右边是函数体 ， 1行可省略花括号。- 已有方法可使用::，左边类/对象， 右边方法名生成lambada如runnable接口中的run方法： Thead  t= new Thead ( () -> System.out.println(); )   ;如  ThreadFactory threadFactory =  r -> new Thread(r, "name");如  Thread  thread = threadFactory.newThread( ()  ->  System.out.println() );如  list.sort(Comparator.comparingInt(Integer::intValue).reversed());lambda中的this指lambda所在的对象，不同于匿名内部类