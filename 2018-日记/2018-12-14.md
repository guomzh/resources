###  2018-12-14

今天的学习内容：

#### 1、学习《spring开发一》线上课程，复习了spring的ioc和aop，在此总结一下我自己的几点新的认识：

* ioc容器作为应用的容器，有点类似map容器，通过been的id来获得这个been。been以依赖注入的方式交由应用的统一容器管理，实现控制反转。
* 有两种场景需要手动在xml里配置been不能使用注解的方式：①第三方类库引入，没有源码，如spring mvc 的org.springframework.web.servlet.DispatcherServlet，需要手动配置。②应用中需要根据不同的参数来对同一个类生成多个been示例放到容器中，即一般注解的方式只生成一个been在容器中。
* 关于spring中been的初始化和销毁的几种实现方式：①使用xml配置的init-method 和 destroy-method，② 使用@PostConstruct（初始化）和@PreDestroy(销毁前清理) 注解来作用于方法，进行初始化和销毁时相关的操作 ③ 实现InitializingBean 接口，复写其中的void afterPropertiesSet() throws Exception方法来初始化



#### 2、针对下午线下课程对aop的讲解，研究学习了一下spring中aop的实现原理和生产中的使用场景，以下为我的一些收获：

关于spring的aop它主要用于我们平时开发的：**spring事务**、日志输出（个性化的参数需用反射获取，有点麻烦）、cache、权限检验（少, 可以通过过滤器等方式处理）

spring中关于aop的实现是：若目标对象没有实现任何接口，spring使用cglib进行动态代理。若目标对象实现了接口，spring默认使用JDK的动态代理。因为有接口，所以使系统更加松耦合，缺点是为每一个目标类创建接口。

我理解的cglib是：它通过操作字节码技术，生成目标对象的一个子类（moke对象），对父类的某些方法进行重写，使用aop时调用是子类的某个目标方法，在这个方法中进行了目标代码织入，达到运行时增强，面向切面编程的效果。



问题与解决：

① 关于spring事务的一个场景原理认识：

如果X类中有两个方法A() ,  B() , 在A方法中使用了@Transactional 声明式事务，而B方法中没有使用事务，但B方法中调用了A方法，那么在这个调用A的事务生效吗？

事实上B方法中调用A方法事务不会生效，因为Aop中cglib技术会产生一个子类，通过Aop,直接调用A()方法时调用的是实现了事务的子类方法，而B方法没有声明式事务，对它的调用还是原来的父类的B方法，没有切入事务逻辑，因此调用B方法事务不会生效。

②在代码中私有方法加声明式事务@Transactional是不会生效的，同样从cglib技术的原理可知，cglib技术生成的目标对象的子类是重写不了父类的私有方法的。



